library(usethis)
use_mit_license()
options(usethis.full_name = "William Chase")
use_mit_license()
use_readme_rmd()
use_testthat()
use_spell_check()
install.packages("spelling")
use_spell_check()
use_data_raw()
use_data()
use_data("D:/R projects/afm_R/500nm_1.txt")
use_package("dplyr")
use_package("readr")
use_package("stringr")
use_package("tibble")
use_package("tidyr")
use_package("purrr")
use_package("rayshader")
use_package("EBImage")
usethis::use_usethis()
use_r("afm_extract_param")
load_all()
afm_extract_param()
load_all
load_all()
load_all()
extract_parameter <- function(header, parameter){
parameter_regex <- paste0("\\\\", parameter, ":")
parameter_text <- header[str_detect(header, parameter_regex)][1]
if (is.na(parameter_text)) {
warning(paste(parameter, "was not found in the header, returning", parameter, "directly"))
return(parameter)
} else {
tryCatch({readr::parse_number(parameter_text)},
warning = function(w){str_extract(parameter_text, pattern = '(?<=: )(.*)(?=")')})
}
}
#reads the scan data into a dataframe
#add later: automatic naming of columns
#add later: safety to check that all lines are complete
extract_scan_points <- function(data){
afm_df <- data %>%
str_squish() %>%
as.tibble() %>%
slice(-1) %>%
tidyr::separate(., col = value,
into = c("Height_Sensor(nm)", "Peak_Force_Error(nN)", "DMTModulus(MPa)", "LogDMTModulus(log(Pa))", "Adhesion(nN)", "Deformation(nm)", "Dissipation(eV)", "Height(nm)"),
sep = " ") %>%
mutate_all(funs(as.numeric(.)))
}
#formats a data channel as a matrix for visualization
#provide channel argument as character vector that matches the colname in scan_points exactly
afm_matrix <- function(data, samps_line, afm_lines, channel = ""){
data %>%
pull(channel) %>%
matrix(., ncol = samps_line, nrow = afm_lines, byrow = TRUE)
}
#takes required inputs (scan size, scan points, samps per line, lines)
#also takes optional params and maps (image matrices)
#formats as afm_scan object
afm_scan <- function(scan_points, scanSize, sampsPerLine, afmLines, maps = list(), optional_params = list()){
#arguments <- list(...)
#maps <- Filter(is.matrix, arguments)
#opt_params <- arguments[!(names(arguments)%in%names(maps))]
data <- list(
params = list(scan_size = scanSize, samps_per_line = sampsPerLine, afm_lines = afmLines),
scan_data = scan_points,
opt_params = optional_params,
maps = maps
)
class(data) <- "afm_scan"
return(data)
}
#reads a bruker text file that has a header and scan data from any number of channels
afm_read_bruker <- function(file, maps = "all", opt_params = list(), scan_size = "Scan Size", samps_per_line = "Samps/line", afm_lines = "Lines"){
afm_text <- read_lines(file)
afm_header <- afm_text[str_detect(afm_text, "\\\\")]
afm_data <- afm_text[((2*length(afm_header))+1):length(afm_text)]
scanSize <- extract_parameter(afm_header, scan_size)
sampsPerLine <- extract_parameter(afm_header, samps_per_line)
afmLines <- extract_parameter(afm_header, afm_lines)
scan_points <- extract_scan_points(afm_data)
if(maps == "all"){
all_channels <- colnames(scan_points)
map_names <- paste(str_extract(all_channels, pattern = ".+?(?=\\()"), "matrix", sep = "_")
afm_maps <- map(.x = all_channels, ~afm_matrix(scan_points, sampsPerLine, afmLines, channel = .x))
names(afm_maps) <- map_names
} else{
all_channels <- colnames(scan_points)
select_channels <- maps[maps%in%all_channels]
map_names <- paste(str_extract(select_channels, pattern = ".+?(?=\\()"), "matrix", sep = "_")
afm_maps <- map(.x = select_channels, ~afm_matrix(scan_points, sampsPerLine, afmLines, channel = .x))
names(afm_maps) <- map_names
}
optional_params <- purrr::map(opt_params, ~extract_parameter(afm_header, .x))
afm_scan(scan_points, scanSize, sampsPerLine, afmLines, maps = afm_maps, optional_params)
}
#### test
afm_text <- read_lines("500nm_1.txt")
library(readr)
library(tidyverse)
#### test
afm_text <- read_lines("500nm_1.txt")
#### test
afm_text <- read_lines("D:/R projects/afm_R/500nm_1.txt")
afm_header <- afm_text[str_detect(afm_text, "\\\\")]
afm_data <- afm_text[((2*length(afm_header))+1):length(afm_text)]
use_data(afm_data)
use_data(afm_header)
use_data(afm_text)
one_um_scan <-afm_read_bruker("D:/R projects/afm_R/500nm_1.txt")
two_um_scan <- afm_read_bruker("D:/R projects/afm_R/2um_1.txt")
use_data(one_um_scan)
use_data(two_um_scan)
#' are not included in the nanoscope output, but might be important for a user such as
#' "treatment" "cell#" "material
#'
#' @param header The AFM file header as a character vector.
#' @param parameter The parameter to extract from the header.
#'
#' @return
#' @export
#'
#' @examples
afm_extract_param <- function(header, parameter){
parameter_regex <- paste0("\\\\", parameter, ":")
parameter_text <- header[str_detect(header, parameter_regex)][1]
if (is.na(parameter_text)) {
warning(paste(parameter, "was not found in the header, returning", parameter, "directly"))
return(parameter)
} else {
tryCatch({readr::parse_number(parameter_text)},
warning = function(w){str_extract(parameter_text, pattern = '(?<=: )(.*)(?=")')})
}
}
document()
?afm_extract_param
document()
?afm_extract_param
document()
find_rtools()
library(pkgbuild)
find_rtools()
use_usethis()
load_all()
document()
check()
use_r("afm_extract_scan_points")
use_r("afm_matrix")
use_r("afm_scan")
use_r("afm_read_bruker")
library(assertive)
install.packages("here")
